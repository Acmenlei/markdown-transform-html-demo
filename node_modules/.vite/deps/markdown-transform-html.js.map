{
  "version": 3,
  "sources": ["../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/utils/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseBlock.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/languages/js/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/languages/html/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/languages/c/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/languages/java/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/languages/ts/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/languages/index.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseCode.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseNoOrderList.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseImage.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseSuperLink.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseOrderList.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseText.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseTitle.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseTable.ts", "../../.pnpm/markdown-transform-html@1.3.9/node_modules/markdown-transform-html/lib/core/parseToHTML.ts"],
  "sourcesContent": ["import { IListItem } from \"../lib/core/parseNoOrderList\";\n// \u6B63\u5219\nexport const matchTitle: RegExp = /(#+)\\s(.*)/g, matchOrderList = /^\\s*(\\d)\\./,\n  matchSuperLink = /\\[(.*)\\]\\((.*)\\)/, matchImage = /!\\[(.*)\\]\\((.*)\\)/,\n  matchSpecComments = /\\/\\*(.*)\\*\\//g, matchFunction = /(function)([\\s\\(&lt])/g;\n\nexport function processForamt(list: string[]) {\n  // \u591A\u4E2A\u6362\u884C\u5408\u5E76\u4E3A\u4E00\u4E2A\n  if (/^\\s+/.test(list[0])) {\n    list[0] = list[0].replace(/^(\\s+)/g, ($1) => '\\n')\n  }\n  // \u5982\u679C\u7B2C\u4E00\u4E2A\u5143\u7D20\u6CA1\u6709\u6362\u884C\u7B26 \u90A3\u4E48\u5C31\u7ED9\u4ED6\u52A0\u4E0A\uFF08\u540E\u7EED\u7684\u5224\u65AD\u9700\u8981\u4F9D\u8D56\u6362\u884C\u7B26\uFF09\n  if (!list[0].startsWith('\\n')) {\n    list[0] = '\\n' + list[0];\n  }\n}\n// \u6709\u5E8F\u5217\u8868\u65E0\u5E8F\u5217\u8868\u7684\u751F\u6210\nexport function genTemplateStringOfNodes(nodes: IListItem[], isOrder: boolean) {\n  let listString = \"\";\n  for (let node of nodes) {\n    let childrenString = node.children.length ? genTemplateStringOfNodes(node.children, isOrder) : '';\n    listString += `<li>${node.value}${childrenString}</li>`\n  }\n  return `<${isOrder ? 'ol' : 'ul'}>${listString}</${isOrder ? 'ol' : 'ul'}>`\n}\n\nexport function isOrderList(s: string) {\n  return matchOrderList.test(s)\n}\n\nexport function isNoOrderList(s: string) {\n  return s.indexOf(\"-\") != -1\n}\n\nexport function isTitle(s: string) {\n  return s.indexOf(\"#\") != -1\n}\n\nexport function isImage(s: string) {\n  return matchImage.test(s)\n}\n\nexport function isSuperLink(s: string) {\n  return matchSuperLink.test(s)\n}\n\nexport function isPreCode(s: string) {\n  return s.startsWith(\"```\")\n}\n\nexport function isBLock(s: string) {\n  return s.startsWith(\"> \")\n}\n\nexport function isNeedEndChar(i: number, n: number, ch: string) {\n  return i < n - 1 ? ch : '';\n}\n\nexport function isHTMLTag(s: string) {\n  return [\"span\", \"p\", \"q\", \"ul\", \"li\", \"ol\", \"div\", \"strong\", \"a\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"i\"]\n    .includes(s)\n}\n// \u6682\u65F6\u5199\u8FD9\u4E48\u591A \u4EE5\u540E\u8865\u5145...\nexport function isFile(s: string) {\n  return [\"txt\", 'vue', 'js', 'css', 'html', 'png', 'jpg', 'gif', 'ts', 'less', 'scss', 'json', 'md'].includes(s);\n}\n// \u666E\u901A\u6570\u636E \u4E0A\u9762\u7684\u5339\u914D\u6761\u4EF6\u90FD\u6CA1\u6709\u88AB\u5339\u914D\u5230 \nexport function isNormalData(content: string) {\n  return !content.includes(\"<\") &&\n    !content.includes(\")\") &&\n    !content.includes(\"(\") &&\n    !content.includes(\"{\") &&\n    !content.includes(\"}\");\n}\n// \u662F\u5426\u662F\u6CE8\u91CA\u8282\u70B9\nexport function isComments(s: string) {\n  return s.startsWith(\"//\") || s.startsWith(\"/*\") || s.startsWith(\"*\") || s.startsWith(\"#\");\n}\n\nexport function isFrontChar(i: number, s: string) {\n  return i !== 0 ? s : ''\n}\n\nexport function isTable(s: string) {\n  return s.trim()[0] === '|';\n}\nexport function isSpecLineComments(s: string) {\n  return matchSpecComments.test(s)\n}\n\nexport function isFuntionKeyWord(s: string) {\n  return matchFunction.test(s)\n}\n\nexport function parseString(text: string) {\n  let result = '', idx = -1;\n  while ((idx = text.indexOf(\"\\\"\")) != -1 || (idx = text.indexOf(\"\\'\")) != -1) {\n    let even = false;\n    text.indexOf('\\\"') != -1 ? even = true : {};\n    result += text.slice(0, idx);\n    text = text.slice(idx + 1)\n    let lastIdx = even ? text.indexOf(\"\\\"\") : text.indexOf(\"\\'\");\n    result += `<q class=declare-string>${text.slice(0, lastIdx)}</q>`;\n    text = text.slice(lastIdx + 1)\n  }\n  text && (result += text);\n  return result;\n}\n\nexport function parseBoolean(s: string) {\n  return s.replace(/([^\\w])(false|true)(?!\\w)/g, ($, $1, $2) => `${$1}<span class=declare-boolean>${$2}</span>`)\n}\n\nexport function parseNumber(s: string) {\n  return s.replace(/([^\\w])(\\d+)(?![\\w\\.])/g, ($, $1, $2) => `${$1}<span class=declare-number>${$2}</span>`)\n}\n\nexport function parseNull(s: string) {\n  return s.replace(/(\\s*null)(?!\\w)/g, ($, $1) => `<span class=declare-operator-char>${$1}</span>`)\n}\n\nexport function native(s: string) {\n  return s.replace(/</g, '&lt;').replace(/>/g, '&gt;')\n}\n\nexport function lineNumber(line: number, need: boolean | undefined) {\n  return need ? `<span class=line-number>${line}</span>` : '';\n}", "export function parseBlock(text: string) {\n  return `<blockquote>${text.slice(2)}</blockquote>`\n}", "import { ITransformOptions } from './../../core/parseToHTML';\nimport {\n  isComments,\n  isFuntionKeyWord,\n  isNeedEndChar,\n  isSpecLineComments,\n  lineNumber,\n  matchFunction,\n  matchSpecComments,\n  native,\n  parseBoolean,\n  parseNull,\n  parseNumber,\n  parseString\n} from \"../../../utils\";\n\nexport default function parseJSSyntax(content: string, line: number, options: ITransformOptions): string {\n  let template = '';\n  let s = content.split('\\n');\n  for (let i = 0; i < s.length; i++) {\n    let sub = s[i];\n    template += analysisOfGrammar(native(sub), line++, options)\n  }\n  return template;\n}\n\n// \u8BED\u6CD5\u5206\u6790\nfunction analysisOfGrammar(s: string, line: number, options: ITransformOptions) {\n  let st: string[] = [], tmpStr = '', l = 0, res = '';\n  // The string must be processed first, and may contain such symbols, affecting subsequent matches\n  s = parseString(s);\n  let n = s.length;\n  for (let i = 0; i < n; i++) {\n    if (s[i] == \")\") {\n      let cur: string | undefined = '';\n      while (st.length && (cur = st.pop()) != '(') {\n        tmpStr = cur + tmpStr;\n      }\n      if (cur != '(') {\n        // \u6362\u884C\u7F3A\u5C11\u5F00\u62EC\u53F7\n        st.push(processParcel(tmpStr + ')', false))\n      } else {\n        l--;\n        st.push(processParcel(tmpStr, true))\n      }\n      tmpStr = '';\n    } else {\n      s[i] == \"(\" && l++;\n      st.push(s[i]);\n    }\n  }\n  let last = 0;\n  while (l--) {\n    last = st.lastIndexOf(\"(\");\n    res = \"(\" + processParcel(st.slice(last + 1).join(\"\"), false) + res;\n    st = st.slice(0, last);\n  }\n  if (st.length) {\n    res = processParcel(st.join(\"\"), false) + res\n  }\n  return `<p>${lineNumber(line, options.lineNumber)}<span>${res}</span></p>`;\n}\n\nfunction processParcel(inner: string, parcel: boolean): string {\n  if (!inner.trim()) {\n    return parcel ? `(${inner})` : inner;\n  }\n  // \u662F\u5426\u662F\u6CE8\u91CA\n  if (isComments(inner.trim())) {\n    return parseSingleComments(inner);\n  }\n  let result = inner;\n  result = parseSpecComents(result)\n  result = parseString(result);\n  result = parseParcelData(result);\n  result = parseOperatorChar(result);\n  result = parseArrowFunction(result);\n  result = parseFuntionExecute(result);\n  result = parseFuntion(result);\n  result = parseBoolean(result);\n  result = parseNumber(result);\n  result = parseNull(result)\n  return parcel ? `(${result})` : result;\n}\n\nfunction parseParcelData(content: string): string {\n  // filter expression syntax\n  // match default value not undefiend\n  if (/^(const|int|string|var|let)/.test(content.trim())) {\n    if (/(\\w+\\s+)(.*\\s*)=(.*)/.test(content)) {\n      return content.replace(/(\\s*\\w+\\s+)(.*\\s*)=(.*)/, ($, $1, $2, $3) => {\n        return `${parseDeclareConstant($1)}${parserSubContent($2)}=${parseParcelData($3)}`\n      })\n    }\n    // match default value is undefiend\n    if (/(\\w+\\s+)(.*\\s*)/.test(content)) {\n      return content.replace(/(\\s*\\w+\\s+)(.*\\s*)/, ($, $1, $2, $3) => {\n        return `${parseDeclareConstant($1)}${parserSubContent($2)}`\n      })\n    }\n  }\n  // process default \n  let result = '';\n  let datas = content.split(\",\");\n  for (let i = 0, n = datas.length; i < n; i++) {\n    result += `${parserSubContent(datas[i])}${isNeedEndChar(i, n, ',')}`\n  }\n  return result;\n}\n\nfunction parserSubContent(s: string) {\n  if (/(\\s*\\w+\\s*)?:(\\s*\\w+\\s*)/.test(s)) {\n    return s.replace(/(\\s*\\w+\\s*)?:(\\s*\\w+\\s*)/, ($, $1, $2) => {\n      if (!$1) {\n        return `:<span class=declare-param-type>${$2}</span>`\n      }\n      return `<span class=declare-param>${$1}</span>:<span class=declare-param-type>${$2}</span>`\n    })\n  }\n  if (isFuntionKeyWord(s)) {\n    return parseFuntion(s)\n  }\n  return s;\n}\n\nfunction parseFuntion(s: string) {\n  return s.replace(matchFunction, ($, $1, $2) => {\n    return `<span class=declare-function>${$1}</span>${$2}`\n  })\n}\n\nfunction parseArrowFunction(content: string) {\n  if (!content.includes(\"=>\")) {\n    return content;\n  }\n  return content.replace(/=>/g, ($) => `<span class=declare-arrow-func>${$}</span>`)\n}\n\nfunction parseFuntionExecute(content: string) {\n  return content.replace(/(\\w+)(\\s*)\\(/g, ($, $1, $2) => `<span class=declare-func-execute>${$1}</span>${$2}(`);\n}\n\nfunction parseDeclareConstant(text: string) {\n  // byte\\[?\\]?\n  return text.replace(/(const|let|var)(\\s+)/gi, ($, $1, $2) => {\n    return `<span class=declare-keyword>${$1}</span><span class=declare-constant-name>${$2}</span>`\n  })\n}\n\nfunction parseOperatorChar(text: string) {\n  if (isSpecLineComments(text)) {\n    return parseSpecComents(text);\n  }\n  return text.replace(/(class|await|in|of|typeof|module|async|this|as|super|module|export\\s+default|export|import|from|while|extends|new|abstract|void|static|return|break|continue|switch|case|finally|try|catch|else|if|throw)(?=[\\s+\\(\\.])/g, ($, $1) => {\n    return `<span class=declare-operator-char>${$1}</span>`\n  })\n}\n\n// \u5355\u884C\u6CE8\u91CA\nfunction parseSingleComments(text: string) {\n  return `<span class=declare-comments>${text}</span>`\n}\n// \u5904\u7406/* */ \u7C7B\u578B\u6CE8\u91CA\nfunction parseSpecComents(text: string) {\n  return text.replace(matchSpecComments, ($) => {\n    return `<span class=declare-comments>${$}</span>`\n  })\n}", "import { isNeedEndChar, lineNumber, native } from \"../../../utils\";\nimport { ITransformOptions } from \"../../core/parseToHTML\";\nimport parseJSSyntax from \"../js\";\n\n// \u5904\u7406html\u8BED\u6CD5\uFF0CTODO: \u5C5E\u6027\u5185\u6362\u884C\u7684\u89E3\u6790...\nexport default function parseHTMLSyntax(syntax: string, line: number, options: ITransformOptions): string {\n  if (/(<!--.*-->)/g.test(syntax)) {\n    // \u5904\u7406\u6CE8\u91CA\u5185\u5BB9\n    return `${genPrefixer(line, options)}<span class=declare-comments>${native(RegExp.$1)}</span></p>`\n  } else if (/(\\s*)<(\\!?\\w+)(.*)>(.*)<\\/\\w+>/g.test(syntax)) {\n    // \u5904\u7406\u6807\u7B7E\u90FD\u5728\u540C\u4E00\u884C\u7684\u60C5\u51B5\n    let attrs = RegExp.$3.trim().split(\" \"), result = processAttrs(attrs);\n    return `${genPrefixer(line, options)}${RegExp.$1}&lt<span class=declare-html-tag>${RegExp.$2}</span>${result && '&nbsp;' + result}&gt${RegExp.$4}&lt/<span class=declare-html-tag>${RegExp.$2}</span>&gt</p>`\n  } else if (/(\\s*)<(\\!?\\w+)(.*)>/g.test(syntax)) {\n    // \u5904\u7406\u53EA\u6709\u5F00\u6807\u7B7E\u7684\u60C5\u51B5\n    let attrs = RegExp.$3.trim().split(\" \"), result = processAttrs(attrs);\n    return `${genPrefixer(line, options)}${RegExp.$1}&lt<span class=declare-html-tag>${RegExp.$2}</span>${result && '&nbsp;' + result}&gt</p>`\n  } else if (/(\\s*)<\\/(\\w+)>/g.test(syntax)) {\n    // \u5904\u7406\u53EA\u6709\u95ED\u6807\u7B7E\u7684\u60C5\u51B5\n    return `${genPrefixer(line, options)}${RegExp.$1}&lt/<span class=declare-html-tag>${RegExp.$2}</span>&gt</p>`\n  } else {\n    // \u5904\u7406\u6807\u7B7E\u4E2D\u95F4\u6587\u672C\u7684\u60C5\u51B5(\u53EF\u80FD\u4E3Ascript\u4E2D\u7684\u811A\u672C)\n    return parseJSSyntax(syntax, line++, options);\n  }\n}\n\n// \u89E3\u51B3\u5197\u4F59\u7684\u5B57\u7B26\u4E32\nfunction genPrefixer(line: number, options: ITransformOptions) {\n  return `<p class=line-code>${lineNumber(line, options.lineNumber)}`\n}\n// \u5904\u7406\u6807\u7B7E\u5185\u90E8\u5C5E\u6027\nfunction processAttrs(attrs: string[]) {\n  let result = '';\n  for (let i = 0, n = attrs.length; i < n; i++) {\n    let attr = attrs[i];\n    if (!attr.trim()) {\n      result += attr;\n      continue;\n    }\n    // \u53EA\u53D6\u7B2C\u4E00\u6B21\u51FA\u73B0\u7684=\uFF08\u5BF9\u4E8Emeta\u6807\u7B7E\u4E2D\u53EF\u80FD\u4F1A\u51FA\u73B0\u5C5E\u6027\u4E2D\u4E5F\u5B58\u5728=\uFF0C\u8FD9\u91CC\u9700\u8981\u6392\u9664\uFF09\n    let splitIdx = attr.indexOf(\"=\");\n    if (splitIdx != -1) {\n      let key = attr.slice(0, splitIdx), value = attr.slice(splitIdx + 1)\n      result += `<span class=declare-attr-key>${key}</span>=<span class=declare-attr-value>${value}</span>${isNeedEndChar(i, n, '&nbsp;')}`\n    } else {\n      // \u5339\u914D\u4E0D\u5230\u5C5E\u6027\u4E86\n      result += attr;\n      continue;\n    }\n  }\n  return result;\n}", "export default function parseCSyntax(): string {\n  return '';\n}", "import {\n  isComments,\n  isNeedEndChar,\n  isSpecLineComments,\n  matchSpecComments,\n  parseBoolean,\n  parseNumber,\n  parseString,\n  parseNull,\n  lineNumber\n} from \"../../../utils\";\nimport { ITransformOptions } from \"../../core/parseToHTML\";\n\nexport default function parseJavaSyntax(content: string, line: number, options: ITransformOptions): string {\n  let template = '';\n  let s = content.split('\\n');\n  for (let i = 0; i < s.length; i++) {\n    let sub = s[i];\n    template += analysisOfGrammar(sub, line++, options)\n  }\n  return template;\n}\n\n// \u8BED\u6CD5\u5206\u6790\nfunction analysisOfGrammar(s: string, line: number, options: ITransformOptions) {\n  let st: string[] = [], tmpStr = '', l = 0, res = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == \")\") {\n      let cur: string | undefined = '';\n      while (st.length && (cur = st.pop()) != '(') {\n        tmpStr = cur + tmpStr;\n      }\n      if (cur != '(') {\n        // \u6362\u884C\u7F3A\u5C11\u5F00\u62EC\u53F7\n        st.push(processParcel(tmpStr + ')', false))\n      } else {\n        l--;\n        st.push(processParcel(tmpStr, true))\n      }\n      tmpStr = '';\n    } else {\n      s[i] == \"(\" && l++;\n      st.push(s[i]);\n    }\n  }\n  let last = 0;\n  while (l--) {\n    last = st.lastIndexOf(\"(\");\n    res = \"(\" + processParcel(st.slice(last + 1).join(\"\"), false) + res;\n    st = st.slice(0, last);\n  }\n  if (st.length) {\n    res = processParcel(st.join(\"\"), false) + res\n  }\n  return `<p>${lineNumber(line, options.lineNumber)}<span>${res}</span></p>`\n}\n\nfunction processParcel(inner: string, parcel: boolean): string {\n  if (!inner.trim()) {\n    return parcel ? `(${inner})` : inner;\n  }\n  // \u662F\u5426\u662F\u6CE8\u91CA\n  if (isComments(inner.trim())) {\n    return parseSingleComments(inner);\n  }\n  let result = inner;\n  result = parseSpecComents(result)\n  result = parseParcelData(result);\n  result = parseOperatorChar(result);\n  result = parseString(result);\n  result = parseFuntionExecute(result)\n  result = parseBoolean(result);\n  result = parseNumber(result);\n  result = parseNull(result);\n  return parcel ? `(${result})` : result;\n}\n\nfunction parseParcelData(content: string): string {\n  // filter expression syntax\n  // match default value not undefiend\n  if (/^(char|int|String|Byte\\[?\\]?|[A-Z]+)/.test(content.trim())) {\n    if (/(\\w+\\s+)(.*\\s*)=(.*)/.test(content)) {\n      return content.replace(/(\\s*\\w+\\s+)(.*\\s*)=(.*)/, ($, $1, $2, $3) => {\n        return `${parseDeclareConstant($1)}${parserSubContent($2)}=${parseParcelData($3)}`\n      })\n    }\n    // match default value is undefiend\n    if (/(\\w+\\s+)(.*\\s*)/.test(content)) {\n      return content.replace(/(\\s*\\w+\\s+)(.*\\s*)/, ($, $1, $2, $3) => {\n        return `${parseDeclareConstant($1)}${parserSubContent($2)}`\n      })\n    }\n  }\n  // process default \n  let result = '';\n  let datas = content.split(\",\");\n  for (let i = 0, n = datas.length; i < n; i++) {\n    result += `${parserSubContent(datas[i])}${isNeedEndChar(i, n, ',')}`\n  }\n  return result;\n}\n\nconst matchNormalType = /(\\s*\\w+\\s*)?:(\\s*\\w+\\s*)/g,\n  matchGenericType = /(:\\s*\\w+\\s*)?&lt;(\\s*\\/?\\s*\\w+\\s*)&gt;/g;\nfunction parserSubContent(s: string) {\n  if (matchGenericType.test(s)) {\n    return s.replace(matchGenericType, ($, $1, $2) => {\n      let rest = $1 ? `<span class=declare-param-type>${$1}</span>` : '';\n      return `${rest}&lt;<span class=declare-param-type>${$2}</span>&gt;`;\n    })\n  }\n  if (matchNormalType.test(s)) {\n    return s.replace(matchNormalType, ($, $1, $2) => {\n      if (!$1) {\n        return `:<span class=declare-param-type>${$2}</span>`\n      }\n      return `<span class=declare-param>${$1}</span>:<span class=declare-param-type>${$2}</span>`\n    })\n  }\n  return s;\n}\n\nfunction parseFuntionExecute(content: string) {\n  return content.replace(/(\\w+)(\\s*)\\(/g, ($, $1, $2) => `<span class=declare-func-execute>${$1}</span>${$2}(`);\n}\n\nfunction parseDeclareConstant(text: string) {\n  return text.replace(/(const|let|var|int|string|Byte\\[?\\]?|[A-Z]+)(\\s+)/gi, ($, $1, $2) => {\n    return `<span class=declare-keyword>${$1}</span><span class=declare-constant-name>${$2}</span>`\n  })\n}\n\nfunction parseOperatorChar(text: string) {\n  if (isSpecLineComments(text)) {\n    return parseSpecComents(text);\n  }\n  return text.replace(/(class|in|of|this|super|interface|module|import|from|extends|new|abstract|void|static|return|break|continue|switch|case|finally|try|catch|else|if|throw)(?=[\\s\\(\\.])/g, ($, $1) => {\n    return `<span class=declare-operator-char>${$1}</span>`\n  })\n}\n\n// \u5355\u884C\u6CE8\u91CA\nfunction parseSingleComments(text: string) {\n  return `<span class=declare-comments>${text}</span>`\n}\n// \u5904\u7406/* */ \u7C7B\u578B\u6CE8\u91CA\nfunction parseSpecComents(text: string) {\n  return text.replace(matchSpecComments, ($) => {\n    return `<span class=declare-comments>${$}</span>`\n  })\n}", "import {\n  isComments,\n  isFuntionKeyWord,\n  isNeedEndChar,\n  isSpecLineComments,\n  lineNumber,\n  matchFunction,\n  matchSpecComments,\n  native,\n  parseBoolean,\n  parseNull,\n  parseNumber,\n  parseString\n} from \"../../../utils\";\nimport { ITransformOptions } from \"../../core/parseToHTML\";\n\nexport default function parseTSSyntax(content: string, line: number, options: ITransformOptions): string {\n  let template = '';\n  let s = content.split('\\n');\n  for (let i = 0; i < s.length; i++) {\n    let sub = s[i];\n    template += analysisOfGrammar(native(sub), line++, options)\n  }\n  return template;\n}\n\n// \u8BED\u6CD5\u5206\u6790\nfunction analysisOfGrammar(s: string, line: number, options: ITransformOptions) {\n  let st: string[] = [], tmpStr = '', l = 0, res = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == \")\") {\n      let cur: string | undefined = '';\n      while (st.length && (cur = st.pop()) != '(') {\n        tmpStr = cur + tmpStr;\n      }\n      if (cur != '(') {\n        // \u6362\u884C\u7F3A\u5C11\u5F00\u62EC\u53F7\n        st.push(processParcel(tmpStr + ')', false))\n      } else {\n        l--;\n        st.push(processParcel(tmpStr, true))\n      }\n      tmpStr = '';\n    } else {\n      s[i] == \"(\" && l++;\n      st.push(s[i]);\n    }\n  }\n  let last = 0;\n  while (l--) {\n    last = st.lastIndexOf(\"(\");\n    res = \"(\" + processParcel(st.slice(last + 1).join(\"\"), false) + res;\n    st = st.slice(0, last);\n  }\n  if (st.length) {\n    res = processParcel(st.join(\"\"), false) + res\n  }\n  return `<p>${lineNumber(line, options.lineNumber)}<span>${res}</span></p>`\n}\n\nfunction processParcel(inner: string, parcel: boolean): string {\n  if (!inner.trim()) {\n    return parcel ? `(${inner})` : inner;\n  }\n  // \u662F\u5426\u662F\u6CE8\u91CA\n  if (isComments(inner.trim())) {\n    return parseSingleComments(inner);\n  }\n  let result = inner;\n  result = parseSpecComents(result)\n  result = parseParcelData(result);\n  result = parseOperatorChar(result);\n  result = parseString(result);\n  result = parseArrowFunction(result)\n  result = parseFuntionExecute(result)\n  result = parseFuntion(result)\n  result = parseBoolean(result);\n  result = parseNumber(result);\n  result = parseNull(result);\n  return parcel ? `(${result})` : result;\n}\n\nfunction parseParcelData(content: string): string {\n  // filter expression syntax\n  // match default value not undefiend\n  if (/^(const|int|string|var|let)/.test(content.trim())) {\n    if (/(\\w+\\s+)(.*\\s*)=(.*)/.test(content)) {\n      return content.replace(/(\\s*\\w+\\s+)(.*\\s*)=(.*)/, ($, $1, $2, $3) => {\n        return `${parseDeclareConstant($1)}${parserSubContent($2)}=${parseParcelData($3)}`\n      })\n    }\n    // match default value is undefiend\n    if (/(\\w+\\s+)(.*\\s*)/.test(content)) {\n      return content.replace(/(\\s*\\w+\\s+)(.*\\s*)/, ($, $1, $2, $3) => {\n        return `${parseDeclareConstant($1)}${parserSubContent($2)}`\n      })\n    }\n  }\n  // process default \n  let result = '';\n  let datas = content.split(\",\");\n  for (let i = 0, n = datas.length; i < n; i++) {\n    result += `${parserSubContent(datas[i])}${isNeedEndChar(i, n, ',')}`\n  }\n  return result;\n}\n\nconst matchNormalType = /(\\s*\\w+\\s*)?:(\\s*\\w+\\s*)/g,\n  matchGenericType = /(:\\s*\\w+\\s*)?&lt;(\\s*\\/?\\s*\\w+\\s*)&gt;/g;\nfunction parserSubContent(s: string) {\n  if (matchGenericType.test(s)) {\n    return s.replace(matchGenericType, ($, $1, $2) => {\n      let rest = $1 ? `<span class=declare-param-type>${$1}</span>` : '';\n      return `${rest}&lt;<span class=declare-param-type>${$2}</span>&gt;`;\n    })\n  }\n  if (matchNormalType.test(s)) {\n    return s.replace(matchNormalType, ($, $1, $2) => {\n      if (!$1) {\n        return `:<span class=declare-param-type>${$2}</span>`\n      }\n      return `<span class=declare-param>${$1}</span>:<span class=declare-param-type>${$2}</span>`\n    })\n  }\n  if (isFuntionKeyWord(s)) {\n    return parseFuntion(s)\n  }\n  return s;\n}\n\nfunction parseFuntion(s: string) {\n  return s.replace(matchFunction, ($, $1, $2) => {\n    return `<span class=declare-function>${$1}</span>${$2}`\n  })\n}\n\nfunction parseArrowFunction(content: string) {\n  if (!content.includes(\"=>\")) {\n    return content;\n  }\n  return content.replace(/=>/g, ($) => `<span class=declare-arrow-func>${$}</span>`)\n}\n\nfunction parseFuntionExecute(content: string) {\n  return content.replace(/(\\w+)(\\s*)\\(/g, ($, $1, $2) => `<span class=declare-func-execute>${$1}</span>${$2}(`);\n}\n\nfunction parseDeclareConstant(text: string) {\n  // byte\\[?\\]?\n  return text.replace(/(const|let|var|int|string)(\\s+)/gi, ($, $1, $2) => {\n    return `<span class=declare-keyword>${$1}</span><span class=declare-constant-name>${$2}</span>`\n  })\n}\n\nfunction parseOperatorChar(text: string) {\n  if (isSpecLineComments(text)) {\n    return parseSpecComents(text);\n  }\n  return text.replace(/(class|in|of|this|super|interface|typeof|module|declare|type|keyof|infer|export\\s+default|export|import|from|extends|new|abstract|void|static|return|break|continue|switch|case|finally|try|catch|else|if|throw)(?=[\\s\\(\\.])/g, ($, $1) => {\n    return `<span class=declare-operator-char>${$1}</span>`\n  })\n}\n\n// \u5355\u884C\u6CE8\u91CA\nfunction parseSingleComments(text: string) {\n  return `<span class=declare-comments>${text}</span>`\n}\n// \u5904\u7406/* */ \u7C7B\u578B\u6CE8\u91CA\nfunction parseSpecComents(text: string) {\n  return text.replace(matchSpecComments, ($) => {\n    return `<span class=declare-comments>${$}</span>`\n  })\n}", "import parseHTMLSyntax from \"./html\"\nimport parseCSyntax from \"./c\"\nimport parseJavaSyntax from \"./java\"\nimport parseJSSyntax from \"./js\"\nimport parseTSSyntax from \"./ts\"\nimport { ITransformOptions } from \"../core/parseToHTML\"\n\nexport type ParserSyntax = (templateLine: string, line: number, options: ITransformOptions) => string;\nexport interface ILanguages {\n  java: ParserSyntax;\n  c: ParserSyntax;\n  ['c++']: ParserSyntax;\n  ['c#']: ParserSyntax;\n  js: ParserSyntax;\n  ts: ParserSyntax;\n  javascript: ParserSyntax;\n  typescript: ParserSyntax;\n  html: ParserSyntax;\n}\n\nconst languages = {\n  ['java']: parseJavaSyntax,\n  ['c']: parseCSyntax,\n  ['c++']: parseCSyntax,\n  ['c#']: parseCSyntax,\n  ['js']: parseJSSyntax,\n  ['javascript']: parseJSSyntax,\n  ['ts']: parseTSSyntax,\n  ['typescript']: parseTSSyntax,\n  ['html']: parseHTMLSyntax,\n}\n\nexport default languages;", "import Parser from \"../languages\";\nimport { ITransformOptions, TemplateList } from \"./parseToHTML\";\nimport { ILanguages } from \"../languages\"\n\n/**\n * \u8FD9\u91CC\u6682\u65F6\u53EA\u5904\u7406\u4E86\u811A\u672C\u548Chtml\uFF0C\u540E\u7EED\u4F1A\u8003\u8651\u7EE7\u7EED\u589E\u52A0\u3002\u3002(\u9664\u4E86\u6807\u8BB0\u8BED\u8A00\uFF0C\u6240\u6709\u8BED\u8A00\u90FD\u662F\u7EDF\u4E00\u8FDB\u884C\u5904\u7406\u7684)\n * @param templates md\u5207\u5272\u540E\u7684\u6A21\u7248\n * @param i \u5F53\u524D\u5F00\u59CB\u5904\u7406\u4F4D\u7F6E\n * @param templateLength \u6A21\u677F\u7684\u603B\u957F\u5EA6\n * @returns \u89E3\u6790\u540E\u7684\u5E26\u8BED\u6CD5\u9AD8\u4EAE\u7684\u4EE3\u7801\u5757\n */\nexport function parseCode(templates: TemplateList, i: number, templateLength: number, options: ITransformOptions) {\n  // console.log(templates)\n  let result = '', language = templates[i].slice(3).trim().toLowerCase(), line = 1;\n  ++i;\n  while (i < templateLength && !templates[i].startsWith(\"```\")) {\n    result += options.highlight ? Parser[language as keyof ILanguages](templates[i], line++, options) : templates[i] + '\\n';\n    i++;\n  }\n  // \u4EE5\u9632\u4E0B\u6B21\u8FDB\u5165, \u7ED3\u675F\u6807\u5FD7\n  templates[i] = '';\n  return { startIdx: i, result: !options.highlight ? `<pre><code>${result}</code></pre>` : `<pre><span class=language>${language}</span><code>${result}</code></pre>` };\n}\n// // \u5904\u7406\u5355\u884Ccode\nexport function parseSingleLineCode(text: string) {\n  let result = '', idx = -1;\n  while ((idx = text.indexOf(\"`\")) != -1) {\n    result += text.slice(0, idx);\n    text = text.slice(idx + 1)\n    let lastIdx = text.indexOf(\"`\");\n    result += `<code class=single-code>${text.slice(0, lastIdx)}</code>`;\n    text = text.slice(lastIdx + 1)\n  }\n  text && (result += text);\n  return result;\n}", "import { genTemplateStringOfNodes, processForamt } from \"../../utils\";\nimport { TemplateList } from \"./parseToHTML\";\n\nexport interface IListItem {\n  value: string;\n  children: Array<IListItem>;\n  level: number;\n  parent: IListItem | null;\n}\n\nexport function parseNoOrderList(templates: TemplateList, i: number, templateLength: number) {\n  let result = '';\n  for (; i < templateLength; i++) {\n    if (templates[i].indexOf(\"-\") != -1) {\n      result += templates[i] + '\\n';\n    } else {\n      break;\n    }\n  }\n  result = processNoOrderList(result);\n  return { startIdx: i, result };\n}\n\nfunction processNoOrderList(template: string) {\n  const list: Array<string> | null = template.match(/(\\s?)+-\\s(.*)/g)\n  if (!list) {\n    return template;\n  }\n  processForamt(list)\n  const nodes = genListHelper(list);\n  const root = genTemplateStringOfNodes(nodes, false);\n  return root;\n}\n\nfunction genListHelper(list: string[]) {\n  const results: IListItem[] = [], currentOperStack: IListItem[] = [], n = list.length;\n\n  for (let i = 0; i < n; i++) {\n    const level = list[i].indexOf(\"-\")\n    const listItem: IListItem = { children: [], value: list[i].slice(level + 1), level, parent: null }\n\n    if (!currentOperStack.length) {\n      results.push(listItem);\n      currentOperStack.push(listItem);\n      continue;\n    }\n    const topLevel = currentOperStack[currentOperStack.length - 1].level;\n    const curLevel = list[i].indexOf(\"-\");\n    let parent: IListItem | null;\n\n    if (topLevel === curLevel) {\n      parent = currentOperStack[currentOperStack.length - 1].parent;\n    } else {\n      if (topLevel > curLevel) {\n        while (currentOperStack[currentOperStack.length - 1].level > curLevel) {\n          currentOperStack.pop()\n        }\n        parent = currentOperStack[currentOperStack.length - 1].parent;\n      } else {\n        parent = currentOperStack[currentOperStack.length - 1];\n      }\n    }\n    listItem.parent = parent;\n    parent ? parent.children.push(listItem) : results.push(listItem);\n    currentOperStack.push(listItem);\n  }\n  return results;\n}", "import { matchImage } from \"../../utils\";\n\nexport function parseImage(s: string) {\n  let result = '';\n  while (matchImage.test(s)) {\n    let altStartIdx = s.indexOf('![');\n    let prefix = s.slice(0, altStartIdx);\n    result += prefix;\n    s = s.slice(altStartIdx + 1);\n    let altEndIdx = s.indexOf('](');\n    let alt = s.slice(0, altEndIdx);\n    s = s.slice(altEndIdx + 2);\n    let linkEnd = s.indexOf(\")\");\n    let link = s.slice(0, linkEnd);\n    s = s.slice(linkEnd + 1);\n    result += `<p><img alt=${alt} src=${link} /></p>`;\n  }\n  return result;\n}", "import { matchSuperLink } from \"../../utils\";\n\nexport function parseSuperLink(s: string) {\n  console.log(s, matchSuperLink.test(s))\n  let result = '';\n  while (matchSuperLink.test(s)) {\n    let altStartIdx = s.indexOf('[');\n    let prefix = s.slice(0, altStartIdx);\n    result += prefix;\n    s = s.slice(altStartIdx + 1);\n    let altEndIdx = s.indexOf('](');\n    let alt = s.slice(0, altEndIdx);\n    s = s.slice(altEndIdx + 2);\n    let linkEnd = s.indexOf(\")\");\n    let link = s.slice(0, linkEnd);\n    s = s.slice(linkEnd + 1);\n    result += `<a href=${link}>${alt}</a>`;\n  }\n  return result;\n}", "import { TemplateList } from \"./parseToHTML\";\nimport { IListItem } from './parseNoOrderList';\nimport { genTemplateStringOfNodes, matchOrderList, processForamt } from \"../../utils\";\n\nexport function parseOrderList(templates: TemplateList, i: number, templateLength: number) {\n  let result = '';\n  for (; i < templateLength; i++) {\n    if (matchOrderList.test(templates[i])) {\n      result += templates[i] + '\\n';\n    } else {\n      break;\n    }\n  }\n  result = processOrderList(result);\n  return { startIdx: i, result };\n}\n\nexport function processOrderList(template: string) {\n  const list: Array<string> | null = template.match(/\\s*\\d\\.(.*)/g)\n  if (!list) {\n    return template;\n  }\n  processForamt(list)\n  const nodes = genListHelper(list);\n  const root = genTemplateStringOfNodes(nodes, true);\n  return root;\n}\n\nfunction genListHelper(list: string[]) {\n  const results: IListItem[] = [], currentOperStack: IListItem[] = [], n = list.length;\n  for (let i = 0; i < n; i++) {\n    let level = 0;\n    if (matchOrderList.test(list[i])) {\n      level = list[i].indexOf(String(RegExp.$1 + \".\"));\n    }\n    const listItem: IListItem = { children: [], value: list[i].slice(level + 2), level, parent: null }\n\n    if (!currentOperStack.length) {\n      results.push(listItem);\n      currentOperStack.push(listItem);\n      continue;\n    }\n    const topLevel = currentOperStack[currentOperStack.length - 1].level;\n    const curLevel = level;\n    let parent: IListItem | null;\n\n    if (topLevel === curLevel) {\n      parent = currentOperStack[currentOperStack.length - 1].parent;\n    } else {\n      if (topLevel > curLevel) {\n        while (currentOperStack[currentOperStack.length - 1].level > curLevel) {\n          currentOperStack.pop()\n        }\n        parent = currentOperStack[currentOperStack.length - 1].parent;\n      } else {\n        parent = currentOperStack[currentOperStack.length - 1];\n      }\n    }\n    listItem.parent = parent;\n    parent ? parent.children.push(listItem) : results.push(listItem);\n    currentOperStack.push(listItem);\n  }\n  return results;\n}\n\n", "export function parseNormalText(text: string) {\n  let result = processStrongText(text);\n  result = processObliqueText(result);\n  return `<p>${result}</p>`;\n}\n\nfunction processStrongText(text: string) {\n  let result = '', idx = -1;\n  while ((idx = text.indexOf(\"**\")) != -1) {\n    result += text.slice(0, idx);\n    text = text.slice(idx + 2)\n    let lastIdx = text.indexOf(\"**\");\n    result += `<strong>${text.slice(0, lastIdx)}</strong>`;\n    text = text.slice(lastIdx + 2)\n  }\n  text && (result += text);\n  return result;\n}\n\nfunction processObliqueText(text: string) {\n  let result = '', idx = -1;\n  while ((idx = text.indexOf(\"*\")) != -1) {\n    result += text.slice(0, idx);\n    text = text.slice(idx + 1)\n    let lastIdx = text.indexOf(\"*\");\n    result += `<i>${text.slice(0, lastIdx)}</i>`;\n    text = text.slice(lastIdx + 1)\n  }\n  text && (result += text);\n  return result;\n} ", "export function getTitleLevel(level: string) {\n  return level.length > 6 ? 6 : level.length;\n}\n", "export function parseTable(templates: string[], i: number, templateLength: number) {\n  let result = '<table>';\n  // \u5904\u7406\u6807\u9898\n  result += processTableTHead(templates[i]);\n  result += `<tbody >`;\n  ++i;\n  for (; i < templateLength; i++) {\n    if (templates[i].trim()[0] === '|') {\n      result += processTabletBody(templates[i]);\n    } else {\n      break;\n    }\n  }\n  result += `</tbody></table>`;\n  return { startIdx: i - 1, result };\n}\n\nfunction processTableTHead(s: string) {\n  let preIdx = -1, template = '<thead><tr>';\n  for (let i = 0, n = s.length; i < n; i++) {\n    if (s[i] == '|' && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {\n      if (preIdx != -1) {\n        template += `<th>${s.slice(preIdx + 1, i)}</th>`\n      }\n      preIdx = i;\n    }\n  }\n  return template + `</tr></thead>`;\n}\n\nfunction processTabletBody(s: string) {\n  let preIdx = -1, template = '<tr>';\n  for (let i = 0, n = s.length; i < n; i++) {\n    if (s[i] == '|' && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {\n      if (preIdx != -1) {\n        let cnts = s.slice(preIdx + 1, i);\n        if (cnts.trim()[0] === '-') {\n          continue;\n        }\n        template += `<td>${cnts}</td>`\n      }\n      preIdx = i;\n    }\n  }\n  return template + `</tr>`;\n}\n\nfunction isValidedSplitChar(s: string, i: number) {\n  return s[i] === ' ' || s[i] == undefined;\n}", "import { isTable, matchTitle } from './../../utils/index';\nimport { parseBlock } from \"./parseBlock\";\nimport { parseSingleLineCode, parseCode } from \"./parseCode\";\nimport { parseNoOrderList } from \"./parseNoOrderList\";\nimport { parseImage } from \"./parseImage\";\nimport { parseSuperLink } from \"./parseSuperLink\";\nimport { parseOrderList } from \"./parseOrderList\"\nimport { parseNormalText } from \"./parseText\";\nimport { getTitleLevel } from \"./parseTitle\";\nimport { isBLock, isImage, isNoOrderList, isOrderList, isPreCode, isSuperLink, isTitle } from \"../../utils\";\nimport { parseTable } from './parseTable';\n\nexport type TemplateList = string[];\nexport type TemplateStr = string;\nexport interface ITransformOptions {\n  lineNumber?: boolean;\n  highlight?: boolean;\n}\n\nconst defaultOptions: ITransformOptions = {\n  lineNumber: false,\n  highlight: false\n}\n\nexport default function markdownToHTML(template: string, options?: ITransformOptions) {\n  const templates: TemplateList = template.split('\\n');\n  let templateStr: TemplateStr = '', len = templates?.length || 0;\n  for (let i = 0; i < len;) {\n    if (isTitle(templates[i])) {\n      // \u8BF4\u660E\u4E3A\u6807\u9898\n      let curTitle = templates[i].trim();\n      templateStr += curTitle.replace(matchTitle, ($1, $2, $3) => {\n        return `<h${getTitleLevel($2)}>${$3}</h${getTitleLevel($2)}>`;\n      });\n    } else if (isTable(templates[i])) {\n      const { result, startIdx } = parseTable(templates, i, len)\n      // \u91CD\u7F6E\u5F00\u59CB\u68C0\u7D22\u7684\u4F4D\u7F6E\n      i = startIdx;\n      // \u5C06\u89E3\u6790\u5F97\u5230\u7684\u7ED3\u679C\u8FDB\u884C\u62FC\u63A5\n      templateStr += result;\n    } else if (isImage(templates[i])) {\n      // \u8BF4\u660E\u4E3A\u56FE\u7247\n      templateStr += parseImage(templates[i]);\n    } else if (isSuperLink(templates[i])) {\n      // \u8BF4\u660E\u4E3A\u8D85\u94FE\u63A5\n      templateStr += parseSuperLink(templates[i]);\n    } else if (isNoOrderList(templates[i])) {\n      // \u8BF4\u660E\u4E3A\u65E0\u5E8F\u5217\u8868\n      const { result, startIdx } = parseNoOrderList(templates, i, len);\n      i = startIdx;\n      templateStr += result;\n    } else if (isOrderList(templates[i])) {\n      // \u8BF4\u660E\u4E3A\u6709\u5E8F\u5217\u8868\n      const { result, startIdx } = parseOrderList(templates, i, len);\n      i = startIdx;\n      templateStr += result;\n    } else if (isPreCode(templates[i])) {\n      // \u4EE3\u7801\u5757\n      const { result, startIdx } = parseCode(templates, i, len, options || defaultOptions);\n      i = startIdx;\n      templateStr += result;\n    } else if (isBLock(templates[i])) {\n      // \u8BF4\u660E\u4E3A\u4EE3\u7801\u5757\n      templateStr += parseBlock(templates[i]);\n    } else {\n      // \u5904\u7406\u666E\u901A\u6587\u5B57\n      if (templates[i] = templates[i].trim()) {\n        templateStr += parseSingleLineCode(parseNormalText(templates[i]));\n      }\n    }\n    i++;\n  }\n  return templateStr;\n}\n"],
  "mappings": "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",
  "names": ["analysisOfGrammar", "processParcel", "parseSingleComments", "parseSpecComents", "parseParcelData", "parseOperatorChar", "parseFuntionExecute", "parseDeclareConstant", "parserSubContent", "analysisOfGrammar", "processParcel", "parseSingleComments", "parseSpecComents", "parseParcelData", "parseOperatorChar", "parseArrowFunction", "parseFuntionExecute", "parseFuntion", "parseDeclareConstant", "parserSubContent", "matchNormalType", "matchGenericType", "genListHelper"]
}
